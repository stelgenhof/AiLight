/**
 * AiLight Firmware
 *
 * This file is part of the AiLight Firmware.
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * Created by Sacha Telgenhof <me at sachatelgenhof dot com>
 * (https://www.sachatelgenhof.nl)
 * Copyright (c) 2016 - 2020 Sacha Telgenhof
 */

const {
    gulp,
    src,
    dest,
    series
} = require('gulp');
const fs = require('fs');
const del = require('del');
const plumber = require('gulp-plumber');
const sass = require('gulp-sass');
const cssBase64 = require('gulp-css-base64');
const favicon = require('gulp-base64-favicon');
const inline = require('gulp-inline');
const clean_css = require('gulp-clean-css');
const html_min = require('gulp-htmlmin');
const gzip = require('gulp-gzip');
const uglify_js = require('uglify-es');
const composer = require('gulp-uglify/composer');
const minify = composer(uglify_js, console);

// Configuration
const sourceFolder = 'src/';
const targetFolder = 'html/';

// Convert the SCSS to CSS
function scss(done) {
    return src(targetFolder + 'style.scss')
        .pipe(plumber())
        .pipe(sass().on('error', sass.logError))
        .pipe(dest('html'));
}

// Base 64 CSS
function base64CSS(done) {
    return src(targetFolder + 'style.css')
        .pipe(cssBase64())
        .pipe(dest('html'));
}

// Clean the generated output files
function clean(done) {
    del([sourceFolder + 'html.*']);
    del([sourceFolder + '*.html']);
    del([targetFolder + '*.css']);

    done();
}

// Process HTML files
function html(done) {
    return src(targetFolder + '*.html')
        .pipe(favicon())
        .pipe(inline({
            js: function () {
                return minify({
                    mangle: true
                });
            },
            css: [clean_css],
            disabledTypes: ['svg']
        }))
        .pipe(html_min({
            collapseWhitespace: true,
            removeComments: true,
            removeEmptyAttributes: true,
            includeAutoGeneratedTags: false,
            minifyCSS: true,
            minifyJS: true
        }))
        .pipe(gzip())
        .pipe(dest(sourceFolder));
}

// Build the C++ include header file
function header(done) {
    const source = sourceFolder + 'index.html.gz';
    const destination = sourceFolder + 'html.gz.h';

    const ws = fs.createWriteStream(destination);

    ws.on('error', function (err) {
        console.log(err);
    });

    const data = fs.readFileSync(source);

    ws.write('#define html_gz_len ' + data.length + '\n');
    ws.write('const uint8_t html_gz[] PROGMEM = {');

    for (let i = 0; i < data.length; i++) {
        if (i % 1000 === 0) ws.write('\n');
        ws.write('0x' + ('00' + data[i].toString(16)).slice(-2));
        if (i < data.length - 1) ws.write(',');
    }

    ws.write('\n};');
    ws.end();

    // Remove intermediate files
    fs.unlinkSync(source);
    fs.unlinkSync(targetFolder + 'style.css');

    done();
}

// Creates a gamma correction table
// Copy the contents of this file in the lib/AiLight/AiLight.hpp file
function gamma(done) {
    const gamma = 2.8; // Correction factor
    const MAX_IN = 255; // End of INPUT range
    const MAX_OUT = 255; // End of OUTPUT range
    const destination = 'gamma.h';

    const ws = fs.createWriteStream(destination);

    ws.on('error', function (err) {
        console.log(err);
    });

    ws.write('// This table remaps linear input values to nonlinear gamma-corrected output\n');
    ws.write('// values. The output values are specified for 8-bit colours with a gamma\n');
    ws.write('// correction factor of 2.8\n');
    ws.write('const static uint8_t PROGMEM gamma8[256] = {');
    for (let i = 0; i <= MAX_IN; i++) {
        if (i > 0) {
            ws.write(',');
        }

        if ((i & 15) === 0) {
            ws.write('\n');
        }

        const level = (Math.floor(Math.pow(i / MAX_IN, gamma) * MAX_OUT + 0.5));
        ws.write(("    " + level).slice(-4));
    }

    ws.write(' };\n');
    ws.end();

    done();
}

exports.default = series(clean, scss, base64CSS, html, header);
exports.gamma = gamma;